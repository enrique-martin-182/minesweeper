{"ast":null,"code":"// src/app/board/board.component.ts\nimport { EventEmitter } from '@angular/core';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"../cell/cell.component\";\nfunction BoardComponent_div_1_app_cell_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"app-cell\", 4);\n    i0.ɵɵlistener(\"clickCell\", function BoardComponent_div_1_app_cell_1_Template_app_cell_clickCell_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const c_r5 = restoredCtx.index;\n      const r_r2 = i0.ɵɵnextContext().index;\n      const ctx_r6 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r6.revealCell(r_r2, c_r5));\n    })(\"flagCell\", function BoardComponent_div_1_app_cell_1_Template_app_cell_flagCell_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const c_r5 = restoredCtx.index;\n      const r_r2 = i0.ɵɵnextContext().index;\n      const ctx_r9 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r9.toggleFlag(r_r2, c_r5));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const cell_r4 = ctx.$implicit;\n    i0.ɵɵproperty(\"data\", cell_r4);\n  }\n}\nfunction BoardComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵtemplate(1, BoardComponent_div_1_app_cell_1_Template, 1, 1, \"app-cell\", 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const row_r1 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", row_r1);\n  }\n}\nexport let BoardComponent = /*#__PURE__*/(() => {\n  class BoardComponent {\n    constructor() {\n      this.isBlocked = false;\n      this.firstClick = new EventEmitter();\n      this.hitMine = new EventEmitter();\n      this.rows = 10;\n      this.cols = 10;\n      this.mines = 15;\n      this.grid = [];\n      this.hasStarted = false;\n    }\n    ngOnInit() {\n      this.initBoard();\n    }\n    initBoard() {\n      // Igual que antes: genera tablero con minas y conteos\n      const board = Array.from({\n        length: this.rows\n      }, () => Array.from({\n        length: this.cols\n      }, () => ({\n        isMine: false,\n        isRevealed: false,\n        aroundMines: 0,\n        isFlagged: false\n      })));\n      let planted = 0;\n      while (planted < this.mines) {\n        const r = Math.floor(Math.random() * this.rows);\n        const c = Math.floor(Math.random() * this.cols);\n        if (!board[r][c].isMine) {\n          board[r][c].isMine = true;\n          planted++;\n        }\n      }\n      for (let r = 0; r < this.rows; r++) {\n        for (let c = 0; c < this.cols; c++) {\n          if (!board[r][c].isMine) {\n            let count = 0;\n            for (let dr of [-1, 0, 1]) {\n              for (let dc of [-1, 0, 1]) {\n                const nr = r + dr,\n                  nc = c + dc;\n                if (nr >= 0 && nr < this.rows && nc >= 0 && nc < this.cols && board[nr][nc].isMine) count++;\n              }\n            }\n            board[r][c].aroundMines = count;\n          }\n        }\n      }\n      this.grid = board;\n      this.hasStarted = false;\n    }\n    resetBoard() {\n      this.initBoard();\n    }\n    revealCell(r, c) {\n      if (this.isBlocked) return;\n      const cell = this.grid[r][c];\n      if (!this.hasStarted) {\n        this.hasStarted = true;\n        this.firstClick.emit();\n      }\n      if (cell.isRevealed || cell.isFlagged) return;\n      cell.isRevealed = true;\n      if (cell.isMine) {\n        // el jugador pierde\n        this.revealAllMines();\n        this.hitMine.emit();\n        return;\n      }\n      if (cell.aroundMines === 0) {\n        for (let dr of [-1, 0, 1]) {\n          for (let dc of [-1, 0, 1]) {\n            const nr = r + dr,\n              nc = c + dc;\n            if (nr >= 0 && nr < this.rows && nc >= 0 && nc < this.cols) {\n              this.revealCell(nr, nc);\n            }\n          }\n        }\n      }\n    }\n    toggleFlag(r, c) {\n      if (this.isBlocked) return;\n      const cell = this.grid[r][c];\n      if (!cell.isRevealed) {\n        cell.isFlagged = !cell.isFlagged;\n      }\n    }\n    revealAllMines() {\n      for (let row of this.grid) {\n        for (let cell of row) {\n          if (cell.isMine) cell.isRevealed = true;\n        }\n      }\n    }\n  }\n  BoardComponent.ɵfac = function BoardComponent_Factory(t) {\n    return new (t || BoardComponent)();\n  };\n  BoardComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: BoardComponent,\n    selectors: [[\"app-board\"]],\n    inputs: {\n      isBlocked: \"isBlocked\"\n    },\n    outputs: {\n      firstClick: \"firstClick\",\n      hitMine: \"hitMine\"\n    },\n    decls: 2,\n    vars: 3,\n    consts: [[1, \"board\"], [\"class\", \"row\", 4, \"ngFor\", \"ngForOf\"], [1, \"row\"], [3, \"data\", \"clickCell\", \"flagCell\", 4, \"ngFor\", \"ngForOf\"], [3, \"data\", \"clickCell\", \"flagCell\"]],\n    template: function BoardComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, BoardComponent_div_1_Template, 2, 1, \"div\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"blocked\", ctx.isBlocked);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.grid);\n      }\n    },\n    dependencies: [i1.NgForOf, i2.CellComponent],\n    styles: [\".board[_ngcontent-%COMP%]{display:inline-block;border:4px solid #3f51b5;border-radius:8px;padding:8px;background:white;position:relative}.board.blocked[_ngcontent-%COMP%]{pointer-events:none;opacity:.6}.row[_ngcontent-%COMP%]{display:flex}\"]\n  });\n  return BoardComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}